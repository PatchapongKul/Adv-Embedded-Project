#include <Arduino.h>
#include <NTPClient.h>
#include <WiFi.h>
#include <WiFiUdp.h>
#include <esp_task_wdt.h>
#include "secrets.h"
#include <Wire.h>
#include <Arduino_HTS221.h>
#include <PubSubClient.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <AES.h>
#include <Crypto.h>

#define WDT_TIMEOUT 5

AES128 aes128;

WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP);

TwoWire sensor(1);
bool a = sensor.setPins(41, 40);
HTS221Class HTS1(sensor);

QueueHandle_t tempQueue, serverQueue, encryptQueue;

hw_timer_t *timer0 = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;
portMUX_TYPE synch = portMUX_INITIALIZER_UNLOCKED;

WiFiClient espClient;
PubSubClient client(espClient);
HTTPClient http;

const char* mqtt_server = "broker.netpie.io";
String serverPath = "https://ds.netpie.io/feed/api/v1/datapoints/query";

const int mqtt_port = 1883;

long lastMsg = 0;
char msg[50];
int value = 0;

union tmp
{
  float temp;
  uint8_t msg[6];
};

void updateNTP( void * parameter );
void displaySerial( void * parameter );
void readTemp( void * parameter );
void displayTemp( void * parameter );
void send2Server( void * parameter );
void sendEncrypted2Server( void * parameter );
void requestNETPIE (void * parameter);
void postHTTP( void * parameter );
void IRAM_ATTR buttonPress(void);
void IRAM_ATTR onTimer();
void reconnect();
void callback(char* topic, byte* message, unsigned int length);

void setup(){
  esp_task_wdt_init(WDT_TIMEOUT, true); // Initialize the Task Watchdog Timer
  // esp_task_wdt_add(NULL);               // Subscribe current task to the Task Watchdog Timer

  Serial.begin(115200);

  pinMode(2, OUTPUT);
  digitalWrite(2, HIGH);
  pinMode(0, INPUT_PULLUP);
  attachInterrupt(0, buttonPress, FALLING);

  timer0 = timerBegin(0, 80, true);
  timerAttachInterrupt(timer0, &onTimer, true);
  timerAlarmWrite(timer0, 1000000, true);
  timerAlarmEnable(timer0);

  WiFi.begin(ssid, password);
  Serial.println("Connecting to WiFi");
  while ( WiFi.status() != WL_CONNECTED )
  {
    vTaskDelay(100/portTICK_PERIOD_MS);
    esp_task_wdt_reset();
  }
  Serial.println("WiFi Connected");

  // client.setServer(mqtt_server, 1883);
  // client.setCallback(callback);

  if (!HTS1.begin()) {
    Serial.println("Failed to initialize humidity temperature sensor!");
    while (1);
  }
  Serial.println("Initialize Temperature Sensor ..... Done!");

  tempQueue = xQueueCreate( 10, sizeof(float));
  serverQueue = xQueueCreate( 10, sizeof(float));
  encryptQueue = xQueueCreate( 10, sizeof(float));

  timeClient.begin();
  timeClient.update();
  timeClient.setTimeOffset(7*3600); //In Thailand (UTC+7)
  Serial.println("NTP updated");

  // disconnect from WiFi but not erase AP config
  // WiFi.disconnect(false, true);
  // Serial.println("WiFi Disconnected");
  Serial.println("connecting to MQTT");
  client.setServer(mqtt_server, mqtt_port);
  client.connect(clientID, token, secret);
  delay(100);
  
  aes128.setKey(key,16);// Setting Key for AES

  xTaskCreate(updateNTP,"updateNTP",2000,NULL,5,NULL);
  xTaskCreate(displaySerial,"displaySerial",1000,NULL, 4, NULL);
  xTaskCreate(readTemp,"readTemp",1000,NULL, 3, NULL);
  xTaskCreate(displayTemp,"displayTemp",1000,NULL,2,NULL);            
  xTaskCreate(send2Server, "send2Server", 4000, NULL, 1, NULL);
  xTaskCreate(sendEncrypted2Server, "sendEncrypted2Server", 4000, NULL, 1, NULL);
  xTaskCreate(postHTTP, "postHTTP", 8000, NULL, 2, NULL);
}
  
void loop() 
{
  // if (!client.connected()) {
  //   reconnect();
  // }
  // client.loop();

  if (timeClient.getHours() == 18)  // if it's 6 PM
  {
    Serial.println("ESP is going to sleep");
    esp_sleep_enable_timer_wakeup(12*60*60*1e6);  // sleep for 12 hours
    esp_task_wdt_delete(NULL);
    esp_deep_sleep_start();
  }
  // esp_task_wdt_reset();
}

void updateNTP( void * parameter )
{
  // Subscribe current task to the Task Watchdog Timer
  esp_task_wdt_add(NULL);

  uint32_t currentMillis = 0, lastUpdateMillis = 0;

  /* loop forever */
  for(;;)
  {
    currentMillis = millis();
    if (currentMillis - lastUpdateMillis > 60000)
    {
      // WiFi.disconnect();
      WiFi.begin(ssid, password);
      Serial.println("Connecting to WiFi");
      
      while ( WiFi.status() != WL_CONNECTED )
      {
        vTaskDelay(100/portTICK_PERIOD_MS);
        esp_task_wdt_reset();
      }
      Serial.println("WiFi Connected");

      timeClient.update();
      Serial.println("NTP updated");
      
      // disconnect from WiFi but not erase AP config
      // WiFi.disconnect(false, true);
      Serial.println("WiFi Disconnected");

      lastUpdateMillis = currentMillis;
    }
    vTaskDelay(100/portTICK_PERIOD_MS);
    esp_task_wdt_reset();
  }
}

void displaySerial( void * parameter )
{
  // Subscribe current task to the Task Watchdog Timer
  esp_task_wdt_add(NULL);
  
  /* loop forever */
  for(;;)
  {
    Serial.println(timeClient.getFormattedTime());
    vTaskDelay(1000/portTICK_PERIOD_MS);
    esp_task_wdt_reset();
  }
}

void readTemp( void * parameter )
{
  for(;;)
  {
  float temperature = HTS1.readTemperature();

  xQueueSend( tempQueue, ( void * ) &temperature, ( TickType_t ) 0 );
  vTaskDelay(6000/portTICK_PERIOD_MS);
  }
}

void displayTemp( void * parameter )
{
  for(;;)
  {
    float display_temp;
    if( tempQueue != NULL )
      {
        while( xQueueReceive( tempQueue, &( display_temp ),( TickType_t ) 10 ) == pdPASS )
        {
          xQueueSend( serverQueue, ( void * ) &display_temp, ( TickType_t ) 0 );
          vTaskDelay(50/portTICK_PERIOD_MS);
          xQueueSend( encryptQueue, ( void * ) &display_temp, ( TickType_t ) 0 );

          Serial.print("Data from queue ");
          Serial.println(display_temp);
          // Serial.println("°C");
        }
      }
    vTaskDelay(20000/portTICK_PERIOD_MS);
  }
}

void send2Server( void * parameter )
{
  for(;;)
  {
    float temp_data;
    if ( xQueueReceive( serverQueue, &( temp_data ),( TickType_t ) 10 ) == pdPASS )
    {
      // Serial.println("°C");
    
    String sent_data = "{\"data\":{\"temp\":";
    
    sent_data += String(temp_data);
    sent_data += "}}";
          
    if (sent_data.length() > 1)
    {
      while (!client.connected()) 
      {
        reconnect();
      }
      
      client.publish("@shadow/data/update", sent_data.c_str());
      Serial.print("Sent data: ");
      Serial.println(sent_data);
    } 
    }
    vTaskDelay(2000/portTICK_PERIOD_MS);
  }
}

void sendEncrypted2Server( void * parameter )
{
  tmp encrypTemp;
  byte cypherByte[16] = {0};
  String cypherString;
  String sentData;

  for(;;)
  {
    if ( xQueueReceive( encryptQueue, &( encrypTemp.temp ),( TickType_t ) 10 ) == pdPASS )
    {
    // encrypTemp.temp = random(300, 350) / 10.0;
    
    aes128.setKey(key, 16);
    aes128.encryptBlock(cypherByte, encrypTemp.msg);
    
    cypherString = "";
    for(uint8_t i = 0; i < sizeof(cypherByte); i++) {
      cypherString += (cypherByte[i] < 0x10 ? "0" : "") + String(cypherByte[i], HEX);
    }

    StaticJsonDocument<96> dataJSON;
    JsonObject data = dataJSON.createNestedObject("data");
    data["temp"] = encrypTemp.temp;
    data["temp_encrypted"] = cypherString;

    sentData = "";
    serializeJson(dataJSON, sentData);
    
    while (!client.connected()) {
      reconnect();
    }
    
    client.publish("@shadow/data/update", sentData.c_str());
    Serial.print("Sent data: ");
    Serial.println(sentData);
    
    }
    // Serial.println(uxTaskGetStackHighWaterMark(NULL));
    vTaskDelay(5000/portTICK_PERIOD_MS);
  }
}

void reconnect() {
  // Loop until we're reconnected
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    // Attempt to connect
    if (client.connect(clientID, token, secret)) {
      Serial.println("connected");
      // client.subscribe("esp32/output");
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      // Wait 5 seconds before retrying
      delay(5000);
    }
  }
}

void postHTTP( void * parameter )
{
  HTTPClient http;
  StaticJsonDocument<768> jsonResp;
  StaticJsonDocument<384> jsonPost;
  String stringPost;

  tmp decrypTemp;
  byte tempEncrypByte[16] = {0};
  aes128.setKey(key, 16);   // Setting Key for AES

  JsonObject start_relative = jsonPost.createNestedObject("start_relative");
  start_relative["value"] = 1;
  start_relative["unit"] = "days";

  JsonObject metrics_0 = jsonPost["metrics"].createNestedObject();
  metrics_0["name"] = clientID;

  JsonArray metrics_0_tags_attr = metrics_0["tags"].createNestedArray("attr");
  metrics_0_tags_attr.add("temp");
  metrics_0_tags_attr.add("temp_encrypted");
  metrics_0["limit"] = 1;

  JsonObject metrics_0_aggregators_0 = metrics_0["aggregators"].createNestedObject();
  metrics_0_aggregators_0["name"] = "first";

  JsonObject metrics_0_aggregators_0_sampling = metrics_0_aggregators_0.createNestedObject("sampling");
  metrics_0_aggregators_0_sampling["value"] = "1";
  metrics_0_aggregators_0_sampling["unit"] = "minutes";

  serializeJson(jsonPost, stringPost);
  // Serial.println(stringPost);

  String authen = "Device " + String(clientID) + ":" + String(token);

  for(;;)
  {
    http.begin(serverPath.c_str());
    http.addHeader("Authorization", authen);
    http.addHeader("Content-Type", "application/json");
    int httpResponseCode = http.POST(stringPost);
    
    if (httpResponseCode > 0) 
    {
      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
      String payload = http.getString();
      
      // Serial.println(' ');
      // Serial.println(payload);
      // Serial.println(' ');
      
      DeserializationError error = deserializeJson(jsonResp, payload);

      if (error) {
        Serial.print("deserializeJson() failed: ");
        Serial.println(error.c_str());
        vTaskDelay(1000);
        continue;
      }

      JsonObject queries_0_results_0 = jsonResp["queries"][0]["results"][0];
      int64_t timeUTC = queries_0_results_0["values"][0][0];
      float temp = queries_0_results_0["values"][0][1];

      JsonObject queries_0_results_1 = jsonResp["queries"][0]["results"][1];
      int64_t timeUTCEncryp = queries_0_results_1["values"][0][0];
      const char* cypherChar = queries_0_results_1["values"][0][1];

      Serial.print("timestamp: ");
      Serial.print(timeUTC);
      Serial.print("\ttemp: ");
      Serial.println(temp);
      Serial.print("timestamp: ");
      Serial.print(timeUTCEncryp);
      Serial.print("\ttempEncryptedChar: ");
      Serial.println(cypherChar);

      String tmpStr = String(cypherChar);
      byte tmpByte[2] = {0};
      for (uint8_t i = 0, k = 0; i < tmpStr.length(); i++)
      {
        if (tmpStr[i] >= '0' && tmpStr[i] <= '9') {
          tmpByte[k++] = tmpStr[i] - '0';
        }
        else if (tmpStr[i] >= 'a' && tmpStr[i] <= 'f') {
          tmpByte[k++] = tmpStr[i] - 'a' + 10;
        }
        if (k > 1) {
          tempEncrypByte[i/2] = (tmpByte[0] << 4) | tmpByte[1];
          memset(tmpByte, 0, 2);
          k = 0;
        }
      }

      // Serial.print("tempEencrypByte: ");
      // for(uint8_t i = 0; i < sizeof(tempEncrypByte); i++) {
      //   Serial.print((tempEncrypByte[i] < 0x10 ? "0":"") + String(tempEncrypByte[i], HEX));
      // }
      // Serial.println();

      aes128.decryptBlock(decrypTemp.msg, tempEncrypByte);

      Serial.print("Decrypted Temp: ");
      Serial.println(decrypTemp.temp);
    }
    else {
      Serial.print("Error code: ");
      Serial.println(httpResponseCode);
    }
    
    // Serial.println(uxTaskGetStackHighWaterMark(NULL));
    http.end();   // Free resources 
    vTaskDelay(10000);
  }
}

void IRAM_ATTR buttonPress(void)
{
  portENTER_CRITICAL(&synch);
  timerRestart(timer0);
  digitalWrite(2, LOW);
  portEXIT_CRITICAL(&synch); 
}

void IRAM_ATTR onTimer()
{
  portENTER_CRITICAL_ISR(&timerMux);
  digitalWrite(2, HIGH);
  portEXIT_CRITICAL_ISR(&timerMux);
}

void callback(char* topic, byte* message, unsigned int length) {
  Serial.print("Message arrived on topic: ");
  Serial.print(topic);
  Serial.print(". Message: ");
  String messageTemp;
  
  for (int i = 0; i < length; i++) {
    Serial.print((char)message[i]);
    messageTemp += (char)message[i];
  }
  Serial.println();

  // Feel free to add more if statements to control more GPIOs with MQTT
}